pipeline {
    agent any

    environment {
        GO_VERSION = '1.24.0'

        IMAGE_NAME  = 'gogs'
        ECR_NAMESPACE = 'gogs'
        ECR_REPO_NAME = 'images'
        ECR_URI    = "${env.ECR_URI}"
        ECR_REGION  = "${env.ECR_REGION}"
        CREDENTIALS_ID = 'Jenkins_ECR'

        FULL_IMAGE_NAME = "${ECR_NAMESPACE}/${ECR_REPO_NAME}"
    }
    
    tools {
        go "${GO_VERSION}" 
    }
    
    options {
        buildDiscarder(logRotator(daysToKeepStr: '7', numToKeepStr: '10'))
    }

    stages {

        stage('Notify') {
            steps {
                discordSend(
                    webhookURL: env.DISCORD_WEBHOOK,
                    title: env.JOB_NAME,
                    link: env.BUILD_URL,
                    description: "Pipeline Started: build ${env.BUILD_NUMBER}",
                    result: 'ABORTED',
                )
            }
        }

        // stage('Git Clone') {
        //     steps {
        //         sh'go version'
        //         git branch: 'main', credentialsId: 'gogs_jenkins_github_app', url: 'https://github.com/finkord/gogs'
        //     }
        // }

        stage('Validate and Generate Code') {
            steps {
                sh"go mod tidy"
                sh"go install golang.org/x/tools/cmd/goimports@latest"
                sh"""
                   export PATH=$PATH:\$(go env GOPATH)/bin
                   CGO_ENABLED=1 go generate ./... 
                """
            }
        }

        stage('Lint') {
            steps {
                script {
                    sh """
                        curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/HEAD/install.sh | sh -s -- -b \$(go env GOPATH)/bin v2.1.6
                        export PATH=$PATH:\$(go env GOPATH)/bin
                        golangci-lint run --timeout=30m
                    """
                }
            }
        }
        
        stage('Test') {
            steps {
                sh 'go test -cover -race -coverprofile=coverage.out -covermode=atomic ./...'
            }
        }

        stage('Prepare Variables') {
            steps {
                script {
                    def branch    = env.GIT_BRANCH?.replaceAll(/^origin\//, '')?.replaceAll('/', '-') ?: 'unknown'
                    def commit    = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
                    def timestamp = sh(returnStdout: true, script: "date +%Y%m%d%H%M%S").trim()
                    env.IMAGE_TAG = "${branch}-${commit}-${timestamp}"
                    echo "Assigned IMAGE_TAG = ${env.IMAGE_TAG}"
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    gogsImage = docker.build("${FULL_IMAGE_NAME}:${env.IMAGE_TAG}")
                    gogsImage.tag('latest')
                }
            }
        }

        stage('Push to AWS ECR') {
            steps {
                script {
                    docker.withRegistry("https://${ECR_URI}", "ecr:${ECR_REGION}:${CREDENTIALS_ID}") {
                        gogsImage.push(env.IMAGE_TAG)
                        gogsImage.push('latest')
                    }
                }
            }
        }
        
        // stage('Build') {
        //     steps {
        //         sh 'go build -v .'
        //     }
        // }
        
        // stage('Artifact Build') {
        //     steps {
        //         script {
        //             def buildArtifactsDir = "artifacts/build_${BUILD_NUMBER}"
        //             sh """
        //             mkdir -p artifacts
        //             mkdir -p ${buildArtifactsDir}/log
        //             mkdir -p ${buildArtifactsDir}/coverages
                    
        //             cp ./gogs ${buildArtifactsDir}/
        //             cp -r ./scripts ${buildArtifactsDir}/scripts
        //             go tool cover -html=coverage.out -o coverage.html
        //             cp ./coverage*.out ${buildArtifactsDir}/coverages/
        //             """
        //             //publishHTML([reportDir: '.', reportFiles: 'coverage.html', reportName: 'Go Coverage'])
        //             archiveArtifacts artifacts: "${buildArtifactsDir}/**", fingerprint: true
        //         }
        //     }
        // }
    }

    post {
        always {
            cleanWs()
        }
        success {
            discordSend(
                webhookURL: env.DISCORD_WEBHOOK,
                title: env.JOB_NAME,
                link: env.BUILD_URL,
                description: "Pipeline Success: build ${env.BUILD_NUMBER}",
                result: 'SUCCESS',
                showChangeset: true,
            )
        }
        failure {
            discordSend(
                webhookURL: env.DISCORD_WEBHOOK,
                title: env.JOB_NAME,
                link: env.BUILD_URL,
                description: "Pipeline Failed: build ${env.BUILD_NUMBER}",
                result: 'FAILURE',
                showChangeset: true,
            )
        }
        aborted {
            discordSend(
                webhookURL: env.DISCORD_WEBHOOK,
                title: env.JOB_NAME,
                link: env.BUILD_URL,
                description: "Pipeline Aborted: build ${env.BUILD_NUMBER}",
                result: 'ABORTED',
            )
        }
    }
}
